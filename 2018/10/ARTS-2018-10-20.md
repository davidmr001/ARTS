
 [Algorithm 理解桶排序算法原理](#algorithm)


 [Review 理解归并排序算法原理 ](#review)


 [Technique 理解基数排序算法原理](#technique)



 [Share 理解递归算法的原理](#share)


# Algorithm


计数排序，基数排序，桶排序是所有排序算法里面时间复杂度能达到O（N）级别的算法，这主要原因是因为他们不采用基于比较的算法，前面的文章已经介绍了计数排序的原理，本片文章我们来学习一下桶排序（Bucket sort)算法。


桶排序的步骤是：

（1）设置一个定量桶的个数，并使用这个数初始化一个数组，元素的类型可以是链表或者数组。

（2）计算出待排序数组的最大值

（3）使用最大值除以桶的个数并向上求整，得到划分区间的divider

（4）遍历待排序数组，取每个元素除以divider并向下取整，放入对应的桶里面

（5）遍历桶数组，对每个桶进行排序，这里排序算法不限，可以采用计数排序，快排，插入都可以。

（6）最终顺序合并每个桶数组，便得到整体有序的数组。


桶排序的平均时间复杂度O（n+k），空间复杂度最快的情况下为O（n*k），桶排序适合数据分布比较均匀
的场景，即每个桶分到的元素个数相差不多，极端情况下，所有的待排序元素都一样，那么最终会分配到一个桶里面
，此时如果还采用了基于比较的排序算法，那么最坏的时间复杂度会达到O（n^2）。

下面看下示例代码：

```
    private static void bucketSort(){

        int arr[]={1,28,29,29,289,89,30,100,43,-2,36,57,58};

        int max=arr[0],min=arr[0];

        for(int i:arr){
            max=Math.max(max,i);
            min=Math.min(min,i);
        }

        System.out.println("范围：["+min+"->"+max+"]");

        int bucketSize=5;

        int divider= (int)Math.ceil( (max+1)/bucketSize);

        System.out.println(" 桶的个数："+bucketSize+" 每个桶的范围："+divider);

        List<Integer>[] storeResults=new ArrayList[bucketSize];

        for (int i = 0; i <arr.length ; i++) {
              int findIndex=(int)Math.floor(arr[i]/divider);
              if(storeResults[findIndex]==null){
                  storeResults[findIndex]=new ArrayList<Integer>();
              }
              storeResults[findIndex].add(arr[i]);
        }

        int ndx=0;
        for(List bucket:storeResults){
            if(bucket==null) continue;
            //每个桶的数据，可以采用不同的排序方式，这里用Java内置的集合排序
            Collections.sort(bucket);
            //排序完的数据，即可归并
            for (Object i:bucket){
                 arr[ndx]=(int)i;
                 ndx++;
            }
        }

        System.out.println("排序后："+ Arrays.toString(arr));
    }
```

上面的实现采用了List来存储每个桶的元素，这里还可以采用链表，这样插入的性能会更好一点，分桶完成之后，对每个桶进行排序，仅仅为了演示，我这里使用的Java的内置集合工具类来排的顺序，这块的排序算法不限制也可以采用计数排序，插入排序等。

最终在每一段排完顺序后依次合并即可，合并的时候不需要做任何额外的比较，这一点区别于归并排序。
![image](https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/Bucket_sort_1.svg/1200px-Bucket_sort_1.svg.png)



总结：

总体来说，桶排序与计数排序类似，计数排序可以认为是分了最大数量的桶排序，而桶排序则是，将一堆数据分了固定数量的桶中，然后对每个桶的中的数据进行排序，最后合并，桶的数量会影响桶排序的性能，并不是越大越好，这个可以根据实际的数量来估算。












# Review
归并排序（Merge）是创建在归并操作上的一种有效的排序算法，其时间复杂度，最好，最坏，平均都是O(nlogn)，空间复杂度为O(n)，是比较排序里面效率非常稳定的一种排序算法。在1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。


图示原理如下：

![image](https://www.geeksforgeeks.org/wp-content/uploads/Merge-Sort-Tutorial.png)

归并排序的实现有递归和迭代两个版本，大多数时候使用递归看起来会更容易理解，所以理解归并排序的关键地方在于理解，其递归分治的思想，如果对于递归算法不熟悉的同学，建议先看我前面递归算法的原理，理解了递归算法，再学习归并排序就会比较容易。


下面我们看下归并排序的Java代码实现:


```shell
  public static void mergeSort(int arr[],int start,int end){

        if(start>=end) return;
        int mid=(start+end)/2;
        //递归切分.
        mergeSort(arr,start,mid);
        mergeSort(arr,mid+1,end);

        //开始归并.
        int i=0;
        int first=start;
        int last=mid+1;
        //临时数组存放交换排序结果.
        int []tmp=new int[end-start+1];

        //基于mid中间点的位置，开始合并两个有序数组.
        while (first<=mid&&last<=end){
            if(arr[first]<arr[last]){
                tmp[i++]=arr[first++];//左边的数据小.
            }else{
                tmp[i++]=arr[last++];//右边的数据小.
            }
        }

        // 第一个while执行过之后，如果符合下面这个.
        //条件就说明，左边的数组元素还有剩余，现在把剩下的全部拷贝到新的有序数组.
        while (first<=mid){
            tmp[i++]=arr[first++];
        }
        // 第一个while执行过之后，如果符合下面这个.
        //条件就说明，右边的数组元素还有剩余，现在把剩下的全部拷贝到新的有序数组.
        while (last<=end){
            tmp[i++]=arr[last++];
        }

        //新排序好的数据归位到，原始数组对应的位置里面.
        int k=0;
        while (start<=end){
            arr[start++]=tmp[k++];
        }

        }

    public static void main(String[] args) {

        int[] input = {8,9,4,-5,6};
        System.out.println("排序前："+ Arrays.toString(input));
        mergeSort(input,0,input.length-1);
        System.out.println("排序后："+ Arrays.toString(input));

    }
```

下面分析下代码逻辑：


（1）定义一个无序的数组

（2）开始分解子问题，使用数组的（开始下标+结束下标）/ 2得到，切分的中间值

（3）递归处理切分的左半部分数组

（4）递归处理切分的右半部分数组

（5）当任务分解到不能在分解的时候，开始执行比较，合并，并返回一个有序的数组

（6）上面的递归依次返回合并有序的数组

（7）直到把最终的排序问题解决



这里说一下代码里在递归分解完毕之后的四个while循环的意义：


第一个：根据循环的条件，合并两个数组，并把结果集临时输出到一个新的数组里面

第二个：检查第一个合并的数组，是否还有剩余元素没有合并，如果有就拷贝剩下的元素到临时输出的新的数组

第三个：检查第二个合并的数组，是否还有剩余元素没有合并，如果有就拷贝剩下的元素到临时输出的新的数组

第四个：将合并完的有序数组，拷贝到原数组里面这个排序的区间内，从而完成局部排序。

重复上面的四个步骤直到，程序退出时，整个数组就排好顺序了。




总结：


本文主要介绍了，归并排序算法的原理和是实现，此外归并排序算法是稳定的，这一点相比同为n(logn)的快速排序来说是一个优点，在使用比较排序要求稳定性的时候，我们应该先考虑到归并排序，如果不要求，那么大多时候快速排序将会是一个不错的选择。



# Technique

基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。

它是这样实现的：将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。最坏时间复杂度O(kN)，最坏空间复杂度O(k+N)，大多数情况下使用的都是LSD，从个位数字开始比较排序。


比如现在对一个大于0的整形数组排序：


```
  int a[] = {53, 3, 542, 748, 14, 214, 154, 63, 616};
```

排序过程如下：

![image](https://images0.cnblogs.com/i/497634/201403/161837176365265.jpg)

下面我们看下在Java代码里面如何实现：


```shell
    private static void radixSort(int []a){
        System.out.println("排序前："+Arrays.toString(a));
        int radix=10; //数字从0到9共有10位
        int exp;
        int max=a[0];
        for (int i = 0; i < a.length; i++) {
            max=Math.max(a[i],max);

        }
        System.out.println("数组最大值："+max);

        //判断一个整数，有多少位数.
        //exp=1  对个位排序.
        //exp=10 对十位排序.
        //exp=100对白位排序.
        //......依次类推.
        for(exp=1;max/exp>0;exp*=10){
            int output[]=new int[a.length];
            int radixArr[]=new int[radix];
            //下面的过程，与计数排序类似.
            for (int i = 0; i < a.length; i++) {
                radixArr[a[i]/exp%radix]++;
            }
            //求和定位，相对位置.
            for (int i = 1; i < radix; i++) {
                radixArr[i]=radixArr[i]+radixArr[i-1];
            }

            for (int i = a.length-1; i>=0 ; i--) {
                //得到每个数字在bucket数组里面的位置.
                int pos=a[i]/exp%radix;
                //得到其的偏移量.
                int offset=radixArr[pos];
                output[offset-1]=a[i];//存放其位置.
                radixArr[pos]--;//基数自减.

            }
            System.out.println("%"+exp+"排序后："+Arrays.toString(output));
            //将排序结果赋值给原数组.
            a=output;

        }

    }
```

下面来详细分析下，代码是如何实现的：

（1）首先定义一个无序数组

（2）找到数组里面的最大值

（3）从1开始，每次乘以10来计算，最大值的位数，有多少位就意味着需要迭代几轮

（4）在对应的每一轮中，采用计数排序原理，将无序数组里面的每一位元素，求得对应位置元素，然后放入radix（0-9）数组中。

（5）对radix数组遍历，求和，计算出每一位在原始数组里面的位置。

（6）遍历无序数组，对每一个位置的元素，根据规则计算出新的位置，然后放入新的同等大小的数组里面

（7）放置完毕后，把引用赋值给原始无序数组，代表一轮迭代完毕。

（8）回到4步骤，重复执行，直到把所有的位置的处理完毕，排序就完成了。


总结：

本文介绍了基数排序算法的原理和实现，本质上基数排序借助了计数排序来完成了无序数组位置的重新定位，在整个过程中并没有出现任何的比较，所以时间复杂度近似为O(k*n)，其中k=最大数值的位数，n为元素总个数。空间复杂度为O(k+n)，整体来说，是一个比较独特的排序算法。











# Share


### 递归算法的概念

递归（Recursion）在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法，其核心思想是分治策略。 递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念。绝大多数编程语言支持函数的自调用，在这些语言中函数可以通过调用自身来进行递归。

### 关于递归算法

在日常开发中，我们使用循环语句远远大于递归，但这不能说明递归就没有用武之地，实际上递归算法的解决问题的步骤更符合人类解决问题的思路，这是递归算法的优点，同时也是它的缺点。递归算法是比较好用，但是理解起来可能不太好理解，所以在递归算法和循环算法对比中，流行一句话：人理解循环，神理解递归。当然这只是一个段子，不过也从侧面反映出递归算法不容易理解的事实。这个我自己也深有体会，就拿排序算法里面的快排和归并排序来说吧，这两种算法采用的都是分治思想来处理排序问题，所以递归在这里就出现了，如果你不理解递归算法，就去学习这两种排序算法，可能理解起来就非常费事，尽管你知道这两种排序的算法原理和它的时间及空间复杂度，但就是不知道它是如何使用递归完成的，所以学习和理解递归算法是非常有必要的。

实际上递归算法的使用场景，远不止上面说的排序算法，在链表，树，图及其他只要符合分治思想的问题中，其实都可以采用递归来处理。



### 递归算法的使用

我们先来看一个Java里面，如何写一个最简单的递归方法：

```
public void recursiveTest(){
    recursiveTest();  //自己调用自己，就叫递归
}
```
上面就是最简单的递归算法，但不是正确的递归算法，一旦运行起来就会抛出栈内存溢出的异常，因为没有退出条件，所以就会进入死循环中，一直都在重复调用自己，递归调用在底层其实是对线程栈的压栈和出栈操作，每调用一次都会压栈一次，并记录相关的局部变量信息，线程栈的内存是非常有限的，而递归调用如果是无限的，那么很快就会消耗完所有的内存资源，最终导致内存溢出，这一点与空的while死循环是不一样的，单纯的死循环会大量的消耗cpu资源，但不会占用内存资源，所以不会导致程序异常。从这一点能看到递归算法其实是更加消耗系统的性能和资源的，尽管有些编程语言可以做尾递归的优化，降低递归对资源的占用程度，但并不大多数语言都可以支持的或者说很完美的支持，Java就是其中之一，并不支持尾递归的调用。

递归的强大之处在于它允许用户用有限的语句描述无限的对象。因此，在计算机科学中，递归可以被用来描述无限步的运算，尽管描述运算的程序是有限的。
这一点是循环不太容易做到的。

编写正确的递归算法，一定要有 ”归“ 的步骤，也就是说递归算法，在分解问题到不能再分解的步骤时，要让递归有退出的条件，否则就会陷入死循环，最终导致内存不足引发栈溢出异常。

下面，我们通过两个例子来学习一下，递归的使用：

例子一：求阶乘


```shell
    public static int factrial(int n){
        if(n<1){
            return 1;
        }
        return  n*factrial(n-1);

    }
```
上面是网上大多数代码的例子，但是对于初学者来言，是不太友好的，因为看不到太多的细节，所以
我改造了一下，实现的是同样的功能，但有详细的步骤，如下：

```shell
   public static int factrialDetail(int n){
        if(n<1){
            System.out.println("拆解问题完毕，开始分而治之");
            return 1;
        }
        System.out.println("f("+n+")="+n+" * f("+(n-1)+")");
        int z= n*factrialDetail(n-1);

        System.out.println("f("+n+")="+z);

        return  z;

    }
```
例如，求5的阶乘，结果输出如下：

```
f(5)=5 * f(4)
f(4)=4 * f(3)
f(3)=3 * f(2)
f(2)=2 * f(1)
f(1)=1 * f(0)
拆解问题完毕，开始分而治之
f(1)=1
f(2)=2
f(3)=6
f(4)=24
f(5)=120
```
从上面的步骤我们可以清晰的看到递归算法的第一步是分治，把复杂的大的问题，给拆分成一个一个小问题，直到不能再拆解，通过退出条件retrun，然后再从最小的问题开始解决，只到所有的子问题解决完毕，那么最终的大问题就迎刃而解。上面的打印信息，符合栈数据结构的定义，先进后出，通过把所有的子问题压栈之后，然后再一个个出栈，从最简单的步骤计算，最终解决大问题，非常形象。

如下图：

一阶段，递推分解任务：

![image](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTdbFJYfYyEZlu0WJ9jhVJz03EE-FVhZNZUb8X2-YVgY6qik3U7)

二阶段：回归分治任务：

![image](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS5jeF_21DUaq_OIaEeVRMst2dBjcvdX_IOMcv2S3lk0xMb4foW8Q)


例子二：斐波那契数列

斐波那契数列是一个经典的数列，其数列符合黄金分割比的规律，数列越大，其前一项与后一项的比值，越接近黄金比例。

用文字来说，就是费波那契数列由0和1开始，之后的费波那契系数就是由之前的两数相加而得出。首几个费波那契系数是：

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233....

下面看下代码：

```shell
    public static int fibonacci(int n){
        if(n<0){
            throw new IllegalArgumentException("传入参数不合法");
        }
        if(n<=2) {
            return 1;
        };
        //先计算第一个递归函数.
        int plusItem1=fibonacci(n-1);
        int plusItem2=fibonacci(n-2);
        int sum=plusItem1+plusItem2;

        return sum;

    }
```
注意上面的代码，是我特意改造过的，并没有直接在返回处相加两个递归函数，而是通过存储到变量之后，在最终返回，这样做的目的，是帮助大家更容易理解递归的运行特点：上面这段代码相比阶乘的例子，稍微复杂了点，因为方法体里面出现了两个递归调用函数，而阶乘的只有一个。


```shell
  int sum=plusItem1+plusItem2;
```
注意这段代码，一定是在分解任务不能再分解的时候，才开始执行，在不能再分解的时候，就意味着该出栈了，这样一来sum的值，会由两个递归函数的结果汇总，然后向上不断的回报并出栈，直到解决顶层的大问题。


如果不理解的同学，可以传入小一点的参数，然后自己可以试着在纸上划一划，关于递归算法的使用，网上还有比较经典的汉诺塔游戏的解法，此外，如果想练手的同学，可以尝试编写一个十进制转其他进制的递归算法。


总结：

本文主要介绍了递归算法的概念和思想原理及使用例子，递归算法在解决特定场景下的问题非常强大，递归算法的使用，关键在于如何把大问题给分解成相同类型的子问题，然后对一个一个子问题各自击破，当所有的子问题都解决了，那么大的问题也就解决了。最后，使用递归算法需要记住，一定要有让递归回归的约束条件，这才是正确编写递归的前提。
















