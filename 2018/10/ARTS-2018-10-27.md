
 [Algorithm 合并两颗树](#algorithm)

 [Review 理解堆排序的原理](#review)

 [Technique 数据结构之树](#technique)

 [Share 如何避免单例模式被破坏](#share)


# Algorithm

https://leetcode.com/problems/merge-two-binary-trees/

```
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
          if(t1==null) return t2;
     if(t2==null) return t1;

     TreeNode newNode=new TreeNode(t1.val+t2.val);
     newNode.left=mergeTrees(t1.left,t2.left);
     newNode.right=mergeTrees(t1.right,t2.right);
     return  newNode;

    }
```



# Review

前面的文章提到过，堆的数据结构其实是一颗二叉树，准确的说是一颗完全二叉树，因此符合完全二叉树的性质：



如果对具有n个节点二叉树的根节点从0开始编号，则序号为i的节点的双亲结点为(i-1)/2,
左孩子的编号为2i+1，
右孩子为2i+2。

如果从1开始编号，则双亲结点编号为i/2，左孩子结点序号为2i，右孩子结点序号为2i+1.

正是由于上面的这种性质，所以决定了堆结构可以采用数组来实现，此外，堆又分最大堆和最小堆：

最大堆：每一个父节点的值，都大于或等于左右两个子节点的值。

最小堆：每一个父节点的值，都小于或等于左右两个子节点的值。


那么堆这种结构是如何用来实现排序的呢？ 这里以最大堆为例，首先给定一个无序的数组，这里我假设元素是[3,-1,4,6]，要想使用堆排序，必须先把这个无序数组给构建成最大堆，在构建完毕后，root节点的值一定是最大的，然后取出最大值，放在原数组的尾部，接着对剩下的数组，继续调整堆，得到最大值，放在数组的倒数第二的位置，依次类推，最终得到一个有序的数组。

图示如下：

[img]


代码已经准备好了，下面我们看看如何在Java中实现：


```shell
    public static void sort(int arr[]){

        //初始化构建一个大顶堆
        for (int i = arr.length/2;i>=0; i--) {
            System.out.println();
            heapAdjust(arr,i,arr.length);
        }
        //原地排序，无序额外的空间辅助
        for (int i =  arr.length-1;i>0; i--) {
            swap(arr,0,i);//将最大的值，放在数组的尾部
            heapAdjust(arr,0,i);//重新调整堆的结构，选举出来新的最大值。
        }

    }

    private static void swap(int[] arr, int index1, int index2) {

        int tmp=arr[index1];//最大值，下标为0的永远是最大值
        arr[index1]=arr[index2];//将最后一位数字与第一位替换
        arr[index2]=tmp;//现在最后一位是最大的


    }

    private static void heapAdjust(int[] arr, int i, int length) {
        int child;
        int father;
        for (father=arr[i];left(i)<length;i=child){
            child=left(i);
            //第一个条件代表必定有右子树，，第二个条件代表左子树小于右子树，则比较右子树和父亲
            if(child!=length-1 && arr[child]<arr[child+1]){
                child++;//加1，代表是右子树
            }
            //如果父节点小于孩子，则进行交换
            if(father<arr[child]){
                arr[i]=arr[child];
            }else{
                //符合大顶堆的结构
                break;
            }

        }
        //此时i的下标代表的是孩子的值，把父亲的数据赋值给孩子。
        arr[i]=father;

    }

    public static int left(int i){
        return 2*i+1;
    }

    public static void main(String[] args) {

        int array[]={3,-1,4,6};
        System.out.println("before: "+ Arrays.toString(array));
        sort(array);
        System.out.println("after: "+Arrays.toString(array));


    }
```


堆排序的最优，最坏及平均时间复杂度均为O(nlogn），空间复杂度为O(1)，由于在比较和交换时不记录状态，所以和快排一样属于不稳定的排序算法。


总结：

本文主要介绍了堆排序的思想，原理和实现，由于堆特殊的数据结构所以在处理一些优先级的任务排序或者求海量数据topN的问题时，具有着明显的优势。

# Technique

### 前言
树（Tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的圣诞树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

每个节点有零个或多个子节点；
没有父节点的节点称为根节点；
每一个非根节点有且只有一个父节点；
除了根节点外，每个子节点可以分为多个不相交的子树；

### 基本术语

节点的度：一个节点含有的子树的个数称为该节点的度；

叶节点或终端节点：度为0的节点称为叶节点；

非终端节点或分支节点：度不为0的节点；

双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；

孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；

兄弟节点：具有相同父节点的节点互称为兄弟节点；

树的度：一棵树中，最大的节点的度称为树的度；

节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；

树的高度或深度：树中节点的最大层次；

堂兄弟节点：双亲在同一层的节点互为堂兄弟；

节点的祖先：从根到该节点所经分支上的所有节点；

子孙：以某节点为根的子树中任一节点都称为该节点的子孙。

森林：由m（m>=0）棵互不相交的树的集合称为森林；


### 树的种类

无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；

有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；

有序树又包括二叉树，堆，B树，字典树（Trie）这些是我们编程里面的重点关注结构。

[img]


### 二叉树

　二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。
　
　二叉树的定义：
　
　二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2的（i-1)次方个结点；深度为k的二叉树至多有2的k次方-1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。

图示如下：

![image](https://images.cnblogs.com/cnblogs_com/ajayumi/ProgramImage/2009050402.jpg)

#### 　满二叉树和完全二叉树：

　　满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。

　　满二叉树的性质：

　　1) 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;

　　2) 叶子数为2h;

　　3) 第k层的结点数是：2k-1;

　　4) 总结点数是：2k-1，且总节点数一定是奇数。

　　完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。

　　注：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。

![image](https://images0.cnblogs.com/i/595738/201403/141749056837546.png)

 二叉树的性质：


```

　　1) 在非空二叉树中，第i层的结点总数不超过2i-1, i>=1;
　　2) 深度为h的二叉树最多有2h-1个结点(h>=1)，最少有h个结点;
　　3) 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;
　　4) 具有n个结点的完全二叉树的深度为log2(n+1);
　　5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：
　　　　若I为结点编号则 如果I>1，则其父结点的编号为I/2；
　　　　如果2I<=N，则其左儿子（即左子树的根结点）的编号为2I；若2I>N，则无左儿子；
　　　　如果2I+1<=N，则其右儿子的结点编号为2I+1；若2I+1>N，则无右儿子。
　　6)给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1)。
　　7)设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i。
```

二叉树的遍历：

（1）前序遍历

（2）中序遍历

（3）后序遍历


前，中，后的意思分别代表在遍历输出时，根节点的位置在什么地方，如果根第一个输出，那么就叫前序遍历，如果根在中间那么就叫中序遍历，如果根最后一个输出，那么就叫后序遍历。



#### 二叉查找树

二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；

（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；

（3）左、右子树也分别为二叉排序树；

（4）没有键值相等的节点。

二叉查找树的性质：

对二叉查找树进行中序遍历，即可得到有序的数列。

其查询的时间复杂度：

它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（我们需要进行n次查找操作），导致退化成线性存储结构。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

二叉查找树的高度决定了二叉查找树的查找效率。这里的高度其实就是决定了搜索的次数。


#### 平衡二叉树

上面提到，普通的二叉树在极端的情况会退化成线性结构，比如出现所有的节点都在左边，或者所有的节点都在右边，这样没法发挥树形结构的威力了。究其原因就是因为其平衡性没有保持，所以才出现了平衡二叉树的概念，为了使得查询，删除，新增能够最大化保持log2N的时间复杂度。


平衡二叉树的定义：

平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。


AVL树

AVL树是最先发明的自平衡二叉查 找树。在AVL树中任何节点的两个儿子子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(log n)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 "An algorithm for the organization of information" 中发表了它。

其实现思路

平衡二叉树就是二叉树的构建过程中，每当插入一个结点，看是不是因为树的插入破坏了树的平衡性，若是，则找出最小不平衡树。在保持二叉树特性的前提下，调整最小不平衡子树中各个结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。简记为： 步步调整，步步平衡 。



红黑树（Red Black Tree）

红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求。

红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

节点是红色或黑色。
根是黑色。
所有叶子都是黑色（叶子是NIL节点）。
每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。



AVL树  vs  红黑树

（1）AVL树的检索效率高于红黑树

（2）红黑树的删除和插入的效率高于AVL树

红黑树以部分平衡的实现，牺牲了微弱的检索性能，但换来了删除和插入的性能

#### 堆

堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。

若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（英语：min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（英语：max heap）。在堆中最顶端的那一个节点，称作根节点（英语：root node），根节点本身没有母节点（英语：parent node）

堆始于 W. J. Williams 在 1964 年发表的堆排序（英语：heap sort），当时他提出了二叉堆树作为此算法的数据结构。堆在戴克斯特拉算法（英语：Dijkstra's algorithm）中亦为重要的关键。

在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。

堆结构天生自带优先级的功能，非常适合对于海量数据求topN的问题。


堆的性质：

堆的实现通过构造二叉堆（binary heap），实为二叉树的一种；由于其应用的普遍性，当不加限定时，均指该数据结构的这种实现。这种数据结构具有以下性质。

任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。
堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。
将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。


### B-,B+,B*树

又称多路查找树，包括B树和拓展的B＋树，和二叉排序树每个结点只能存储一个元素，每个结点的孩子数不多于两个的性质不一样的是， 多路查找树每一个结点的孩子数可以多于两个，每一个结点处都可以存储多个元素 。

它们都是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上，著名的MySQL的索引就是采用的B+树实现的。

从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；

不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；


### Trie字典树

Trie树，即字典树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。

Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

它有3个基本性质：

根节点不包含字符，除根节点外每一个节点都只包含一个字符。


从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。

每个节点的所有子节点包含的字符都不相同。

典型应用场景：

trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。



### 总结

本文主要介绍了数据结构里面有关树家族的相关结构的概念和定义，算是一篇入门级的科普文章，总的来说大类上分二叉树，B树和Trie树。每一种类的树结构分别用于解决不同场景的应用问题，在实际的开发过程中或多或少都会遇到相关的场景，理解和掌握这些知识也是非常重要的。


# Share



单例模式几乎每个开发者都会用，但想要写出比较健壮的单例程序，其实并不容易。

这里不再讨论单例的模式的n种写法，仅仅讨论如何避免单例模式被破坏，看下面的一个例子：


```
public class SimpleSingleton {

    private final static  SimpleSingleton ourInstance = new SimpleSingleton();

    private SimpleSingleton() {
    }

    public static SimpleSingleton getInstance() {
        return ourInstance;
    }
}
```

这是一个最简单的饿汉式的单例实现，在类进行初始化的时候会安全的创建实例，从而不需要同步。但这么实现，真的能保证任何时候只有一个实例吗？

答案是否定的。

在Java里面，创建对象有4种方式：

（1）new

（2）反射

（3）克隆

（4）反序列化

上面实现的单例，我们通过new确实能保证单例，但是后面的几种方式，都会破坏单例模式。

先说反射的方式，反射在带来的灵活性的同时也破坏了Java封装的特性，通过反射可以访问类里面所有的私有属性和方法。所以反射访问私有构造器是可以非常容易的创建的多个对象实例，从而破坏单例模式。


接着说克隆，这个破坏在大部分时候可以避免，因为想要克隆对象，我们必须实现Cloneable接口，然后重写clone方法，在clone的返回值处，可以返回任何实例。


最后说下序列化和反序列化，如果我们的类没有定义序列化的方法，那么在反序列化的时候，会重新生成一个新的实例，所以这也相当于破坏了单例模式。



最后还有一种不常见的破坏的场景，就是通过我们自定义类加载器来加载类，导致类本身都不是同一个类，这种场景在web项目有多级类加载器的时候比较常见，可以通过一个共用的父加载器来解决这个单例的问题，或者通过需要加载单例的类的时候，使用创建该类本身的加载器去创建，如果不在一个线程里面可以通过线程的上下文来传递类加载器。


我们改下改进后的单例模式：

```
public class Singleton implements Serializable,Cloneable {

    //在类初始化期间，执行由JVM保证线程安全
    private static Singleton singleton=new Singleton();


    //避免反射和多类加载器破坏
    private Singleton() {
            if (Singleton.singleton != null) {
                throw new InstantiationError("Creating of this object is not allowed.");
            }

    }

    public static Singleton getInstance(){
        return singleton;
    }

    //避免克隆破坏
    @Override
    protected Object clone() throws CloneNotSupportedException {
        throw new CloneNotSupportedException("Cloning of this class is not allowed");
//        return super.clone();
    }

//    //避免反序列破坏
    protected Object readResolve() {
        return singleton;
    }



}

```




正确的编写单例模式，其实是需要很多注意事项的，所以在jdk5之后，推荐使用枚举来创建单例类，通过枚举创建的类其实已经帮我们考虑到了上面的所有问题，不用担心其他的一些情况，JVM内部在创建的时候会自动给枚举的类做特殊处理，从而保证其在各种情况下保持唯一的实例。















