
 [Algorithm](#algorithm)

 [Review](#review)

 [Technique 关于拷贝对象引用到local变量的一些思考](#technique)

 [Share 再谈方法调用与堆栈](#share)


# Algorithm


# Review


# Technique

在JDK的Java类源码里面，很多工具包的代码都有在使用某个成员变量之前，先拷贝该变量的对象引用到方法的局部变量之中，如下：

比如LinkedList：

```java
public E peek() {
    final Node<E> f = first;
    return (f == null) ? null : f.item;
}

```

HashMap里面：
```java
    public Set<K> keySet() {
        Object var1 = this.keySet;
        if (var1 == null) {
            var1 = new HashMap.KeySet();
            this.keySet = (Set)var1;
        }

        return (Set)var1;
    }
```

同样的还有Stringlim的trim方法：

```java
    public String trim() {
        int len = value.length;
        int st = 0;
        char[] val = value;    /* avoid getfield opcode */

        while ((st < len) && (val[st] <= ' ')) {
            st++;
        }
        while ((st < len) && (val[len - 1] <= ' ')) {
            len--;
        }
        return ((st > 0) || (len < value.length)) ? substring(st, len) : this;
    }
```

一些朋友，可能认为这是多此一举，明明直接使用成员变量就可以了，为什么还要拷贝一次呢，然后再使用，这样做的好处是什么？

JDK大神写的代码，肯定有其考虑的地方，我们来分析下，这么做的好处：

（1）首先方法里面的变量，都在栈上存储，而成员变量的地址是在堆上存储，而栈的存储，通常情况下都会在cpu的缓存里面，堆的存储一般是在主存里面，cpu的缓存要比主内存的块，所以这种写法，在一定程度上算是一种优化，在执行的时候会通过JIT来完成，尤其是在方法里面的循环中使用，比如trim的方法里例子。

（2）还有一种情况，在方法里面，先拷贝引用地址到本地变量，在栈里面是线程安全的，所以对于方法里面的引用本身来说是不会再存在被别的线程修改的风险，期间，如果另外一个线程修改了这个成员变量的引用地址，那么对于已经拷贝的引用，其实是没有感知的。所以从某种程度上说，拷贝引用地址相当于是一个视图。但是需要注意虽然引用地址不变，但是如果引用的内容变了，那么还能被看到的，所以在使用的时候应该注意二者的区别。


下面我们通过一个例子来看一下，先定义一个共享类：

```java
public class ThreadShare {

    public String text="str-0";

    public int count=0;

    public Cat cat1;

    public Cat cat2=new Cat();

    static class Cat{

        public String name="none";

    }
	}

```

上面是共享类里面定义的一些成员变量，现在我们制造一个这样的场景，把同一个类，传递给两个线程，一个是print线程，一个是update线程，首先在print线程的run方法里面，会把这些成员变量都拷贝到local变量里面，然后接着打印一变，接着我们让print线程sleep几秒，同时启动update线程修改这些成员变量的值，最后，我们在分别打印本地local变量的值与直接访问成员变量的值，看看有什么变量。


```java
    public static void main(String[] args) throws InterruptedException {


        ThreadShare share=new ThreadShare();


        Thread printThread=new Thread(new PrintThread(share));
        printThread.setName("打印线程");
        printThread.start();

        Thread.sleep(1000);

        Thread updateThread=new Thread(new UpdateThread(share));
        updateThread.setName("更新线程");

        updateThread.start();




    }

    public static class UpdateThread implements Runnable{
        private ThreadShare threadShare;

        public UpdateThread(ThreadShare threadShare) {
            this.threadShare = threadShare;
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+" 修改成员变量的值......");
            threadShare.text="update";
            threadShare.count=10;
//            threadShare.cat.name="i am tom";
            threadShare.cat1=new Cat();
            threadShare.cat2.name="cat2";

        }
    }


    public static class PrintThread implements Runnable{

        private ThreadShare threadShare;

        public PrintThread(ThreadShare threadShare) {
            this.threadShare = threadShare;
        }

        @Override
        public void run() {

            String threadName=Thread.currentThread().getName();
            String text=threadShare.text;
            int count=threadShare.count;
            Cat cat1=threadShare.cat1;
            Cat cat2=threadShare.cat2;

            System.out.println(threadName+"  初始值 "+text+" "+count+"  "+cat1+" "+cat2.name);
            System.out.println();
            try {
                TimeUnit.SECONDS.sleep(4);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println();
            System.out.println(threadName+"局部变量show： "+text+" "+count+"  "+cat1+"  "+cat2.name);
            System.out.println(threadName+"成员变量show： "+threadShare.text+"   "+threadShare.count+"   "+threadShare.cat1+" "+cat2.name);

        }
    }

```

输出结果如下：

```
打印线程  初始值 str-0 0  null none

更新线程 修改成员变量的值......

打印线程局部变量show： str-0 0  null  cat2
打印线程成员变量show： update   10   basic.reference.ThreadShare$Cat@57eff98f cat2
```


从上面的结果里面，能够看到最后局部变量的值，对于拷贝的引用是没有变化的，但如果是引用的属性变化了（cat2），是可以看到的，这是因为对象数据是在堆上获取的，接着我们看成员变量的值，发现成员变量能看到所有最新的变换，这是因为成员变量的数据就是从堆上获取的。


在上篇文章里面，我们谈到过栈和堆的区别，其中栈里面能够存储基本类型的数据值，还有引用类型的地址值，如果在Java多个线程里面，都访问同一个共享对象，那么要记住，对于引用类型，多个线程里面都会拷贝一份引用地址，对于基本类型就是值本身，多个线程都对基本类型的修改，那么其他的线程是看不到的，谁最后完成就会覆盖之前的结果，对于引用类型，因为对象在堆里面是共享的，实际上引用地址操作的都是同一个对象，所以多线程修改会造成不可预料的结果，这也是为什么在操作共享变量的时候一定需要使用同步和锁的手段来保证正确性的原因。

[img]


总结：

本文主要介绍了在JDK的源码里面，针对一些拷贝成员变量到local变量的代码片段做了分析，理解这个问题的本质在于理解堆和栈的区别，以及Java引用（指针）概念，还有Java内存模型对操作系统映射抽象，此外，方法里面的local变量，还只能被final修饰，只要在使用这个变量前初始化即可，这种用法的目的，其实是为了更好的代码可读性，使用final标记的变量，用来明确的来告诉我们这个类型，在声明之后不能再改变了，这些良好的编程习惯，我们可以日常开发中都可以吸收借鉴，从而写出效率更好，可读性更强的代码。



















# Share



再谈方法调用与堆和栈


在JVM里面，最重要的两个运行时数据区，无非就是堆和栈了。

### 关于堆

堆内存是被多个线程共享的，而栈内存是线程私有的。堆主要用来存储运行时所有的对象数据和各种数组，简单点说通过new创建的实例，都会在堆上分配空间。堆在虚拟机启动时创建，并且堆具有自动垃圾回收的功能，在Java的世界里，程序员是没办法直接销毁你所创建的对象的，一切必须由GC垃圾回收器来完成，也就是你用完后的对象，并不是立即销毁的，而是在下一次gc发生时来完成回收的，堆的内存可以是固定的，也可以动态增长，并且不要求在内存里面是必须连续的，如果计算需要更多的内存，超过了当前有效的内存，那么就会抛出OutOfMemoryError异常。

堆里面还分配了一部分内存用于：

（1）方法区：

主要用来存储我们编译后的代码，包括每个类的结构，字段，方法数据，常量池等，如果内存不足也会发生OutOfMemoryError异常。


（2）运行时常量池

这个其实是方法区里面划分的一个区域，主要用来存储每个类或者接口里面的常量池表，包括我们熟悉的字符串常量池等。如果内存不足也会发生OutOfMemoryError异常


（3）本地的方法栈

为了支持native方法而存在的一部分区域，本地方法栈与虚拟机栈一样，也是线程私有的，发生的异常包括StackOverflowError和OutOfMemoryError。




### 关于栈

栈主要分虚拟机栈和本地方法栈，我们这里仅仅关注虚拟机栈。

我们先来看下Oracle文档的官网解释：

Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at the same time as the thread. A Java Virtual Machine stack stores frames (§2.6). A Java Virtual Machine stack is analogous to the stack of a conventional language such as C: it holds local variables and partial results, and plays a part in method invocation and return. Because the Java Virtual Machine stack is never manipulated directly except to push and pop frames, frames may be heap allocated. The memory for a Java Virtual Machine stack does not need to be contiguous. 


简单的说，栈属于线程私有的，每一个线程都有一个自己的栈，栈里面可以存储数据，这个待会细说。此外还负责方法的调用和返回，java的栈仅仅负责
压栈和出栈，栈内存本身是可以从堆上分配出来的，并且栈内存可以是不连续的。如果线程计算需要一个更大的栈超过了允许的值，就会抛出StackOverflowError异常，如果栈内存还允许动态增加，那么当下一次申请的内存，不满足当前的需要，就会抛出OutOfMemoryError异常。

前面说过栈可以存储数据，这其实是在栈帧（frame）里面完成的，主要存储local变量，也执行动态链接，给方法返回值，还负责分发异常。栈帧与方法与一对一的关系，也就是说，每次虚拟机调用一个方法时，就会生成一个frame，无论是否发生异常，当方法调用完成后总是销毁，正在执行的方法，其frame称为当前栈帧，当前栈帧执行完成会后，就会抛弃，然后继续调用下一个方法的栈帧，此时该栈帧就会变成当前栈帧，直到所有的栈帧执行完毕，程序才运行结束。对一个类的一个方法，在调用时对应一个栈帧，栈帧包含三部分内容：

（1）方法本身的local变量数组

单个local变量的值类型，包括boolean, byte, char, short, int, float, reference, 和 returnAddress，两个local变量可以存储long和double类型的值，注意这些都是定长类型，也就是说在方法里面声明上面提到的类型，其存储可以直接在栈上，但同样的类型如果是成员变量，那么存储就在堆上，这一点需要注意，另外栈上存储的是定长，像字符串（底层是char数组），各种对象实例，数据本身都是存储在堆上，栈里面仅仅存储
指针，也叫内存地址。


（2）方法里面的操作符栈

每个栈帧里面还包含一个后进先出的操作符栈（operand stack），这个主要是进行一些算术运算操作的，比如遇到的加减乘除等操作符等。


（3）当前方法运行时常量池的的引用

这里面主要是一些运行时常量池的引用，用于支持方法代码的动态链接。动态链接主要转变符号链接为真实的链接。



说了这么多，我们总结一下栈的特点：

首先是线程私有的，不同的线程拥有不同的栈，栈里面的数据，相互之前是不可见的。栈里面可以直接存储基本类型的数据，此外包括指针的内存地址，及方法的返回值，这些数据的内存分配都是在栈上，这也是我们为什么说方法里面的local变量是线程安全的原因，因为是线程私有，不涉及多线程的问题。栈里面包含了很多帧，在程序运行时的每个方法，都会生成一个帧入栈，执行的过程就是出栈的过程。如果栈里面引用了成员变量或者其他共享的变量，这个时候需要注意线程安全问题，因为这些变量是存储在堆上的。


最后我们来看下，堆和栈的图示：

![image](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png)



### 一个分析的例子

下面，我们通过一个例子，来简单看下，方法在栈里面是如何执行的：

```
public class StackCallDemo {


    static class Cat{
        public String name;
    }

    public void m1(){
        int x=20;
        m2(x);// call m2 method
    }


    public void m2(int x){
        boolean c;
        m3();//call m3 method
    }


    public void m3(){
        Cat cat=new Cat();
        //more code
    }


    public static void main(String[] args) {


        StackCallDemo stackDemo=new StackCallDemo();
        stackDemo.m1();

    }


}


```


这个类代码非常简单，方法执行逻辑 main=> m1=> m2=> m3，注意这是调用顺序，也是入栈顺序，出栈顺序，也就是真正的执行顺序，刚好相反，图示如下：

[img]


注意每个出栈执行完的方法，就相当于销毁了，在堆里面的Cat对象，如果方法不再引用，那么就再次gc时，会被回收掉。通过上图，我们可以清晰的看到嵌套方法执行过程，想清楚这一点，我们再去理解递归方法就容易多了，如果你按照嵌套的方式，去思考递归，那肯定理解不了，但是我们按照栈的逻辑，去理解递归，就会发现容易多了，这里没有嵌套，只有顺序入栈，出栈，分别对应递和归。



### 总结：


本文主要介绍了Java里面堆和栈在运行时的数据区域和功能，并在文末结合了一个例子来演示了Java程序方法是如何执行的，了解方法的执行逻辑，有助于我们理解其工作原理，从而可以让我们更好的去分析一些复杂的方法逻辑或者算法，比如递归等。


































