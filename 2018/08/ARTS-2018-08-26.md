
 [Algorithm](#algorithm)

 [Review](#review)

 [Technique](#technique)

 [Share](#share)


# Algorithm


# Review


# Technique

CyclicBarrier这个并发工具类和上篇文章中提到的CountDownLatch比较类似，可以把CyclicBarrier看做是可以可以复用的CountDownLatch。


CountDownLatch在Oracle官网文档中定义是，一组线程其他另外一组线程都执行完成之后，该组线程才可以同时进行工作。这和软件开发中协作非常类似，比如dev团队开发完成之后，qa团队才可以进行测试工作。qa团队是一组等待线程，dev团队是一组工作的线程，只有当dev全部完成之后，qa才开始进行测试。


CyclicBarrier在官网的定义是，一组线程中，必须相互等待其他的线程完成之后，他们才可以进入下一个协作项目反复如此。比如还是在软件开发中，一个项目来了，需要同时由后端团队和前端团队都开发完成之后才能提测，否则就相互等待，直到它们全部完成之后，才可以一起进入一个循环中。


我们来看一个非常简单的CyclicBarrier例子：


```

        CyclicBarrier cyclicBarrier=new CyclicBarrier(2, new Runnable() {
            @Override
            public void run() {
                System.out.println("任务完成，触发一次.....");
            }
        });

       Runnable runnable=new Runnable() {
           @Override
           public void run() {
               try {
                   Thread.sleep(1000);
                   cyclicBarrier.await();
               } catch (InterruptedException e) {
                   e.printStackTrace();
               } catch (BrokenBarrierException e) {
                   e.printStackTrace();
               }
           }
       };


       new Thread(runnable).start();
       new Thread(runnable).start();

        new Thread(runnable).start();
        new Thread(runnable).start();
```

输出结果:

```
任务完成，触发一次.....
任务完成，触发一次.....
```

CountDownLatch和CyclicBarrier的不同之处在于：


（1）CountDownLatch仅仅可以使用一次而CyclicBarrier可以循环利用

（2）CountDownLatch类强调的是调用countDown方法的次数，而CyclicBarrier类强调的是至少有N个线程调用await方法。


（3）CyclicBarrier方法可以额外注册一个任务，在每轮循环执行await之后，会由最后一个调用await方法的线程，负责调用额外的任务。如上面的例子。

（4）CountDownLatch的底层使用的AQS的共享锁来实现的，而CyclicBarrier则是由ReentrantLock+Condition实现的相对来说更简单。

关于两者的功能区别，可以看下面两个伪代码：

CountDonwLatch：

```
public class CountDownLatch {
    private Object mutex = new Object();
    private int count;

    public CountDownLatch(int count) {
        this.count = count;
    }

    public void await() throws InterruptedException {
        synchronized (mutex) {
            while (count > 0) {
                mutex.wait();
            }
        }
    }

    public void countDown() {
        synchronized (mutex) {
            if (--count == 0)
                mutex.notifyAll();
        }

    }
}
```

CyclicBarrier：


```
public class CyclicBarrier {
    private Object mutex = new Object();
    private int count;

    public CyclicBarrier(int count) {
        this.count = count;
    }

    public void await() throws InterruptedException {
        synchronized (mutex) {
            count--;
            while(count > 0)
                mutex.wait();
            mutex.notifyAll();
        }
    }
}

```


总结：

本文主要了介绍了Java里面CyclicBarrier类功能以及它与CountDownLatch的区别和联系，最后并给出了实现他们的一些伪代码，两者的主要不同之处在于CyclicBarrier是可以多次复用的一个示例，只要指定的数量的线程调用await方法后，reset重置方法就会自动调用，不需要在代码中显式使用，这一点需要注意。


# Share

CountDownLatch相信大家并不陌生，我们在上篇文章中已经分析其实现，这里在简单回顾一下CountDownLatch是基于AQS共享锁构建的一种同步器，它的主要应用场景有两种：

（1）一个线程等待所有的其他线程执行完任务之后自己再执行自己的任务。

（2）多个线程等待一个线程执行完任务之后，然后多个线程同时开始执行自己的任务。


在实际开发中，可能大家仅仅对第一种场景比较熟悉，而完全忽视了第二种场景，实际上第二种场景才是CountDownLatch发挥共享锁的真正案例。

CountDownLatch的方法主要是：


```

（1）构造方法：

CountDownLatch(int count)
参数count控制线程的数量

（2）await()
阻塞当前调用的线程，直到count的值等于0才唤醒，除非执行了线程中断，否则
在没到达0之前，一直处于waiting状态

（3）await(long timeout, TimeUnit unit)

阻塞当前调用的线程，直到count的值等于0才唤醒，除非执行了线程中断或者指定的时间周期过期，否则在没到达0之前，一直处于waiting状态

（4）countDown()
每次调用对count的值减1，当这个值到达0的时候，会释放所有等待的线程。


（5）getCount()
 返回当前count的数量

```

下面我们看一个比较典型的一个例子：

```
 package concurrent.tools;

import java.util.Random;
import java.util.concurrent.CountDownLatch;

/**
 * Created by Administrator on 2018/8/20.
 */
public class CountDownDemo2 {





    static class Worker implements Runnable{

        private final CountDownLatch startSignal;
        private final CountDownLatch dongSignal;

        Worker(CountDownLatch startSignal,CountDownLatch dongSignal){
            this.startSignal=startSignal;
            this.dongSignal=dongSignal;
        }
        @Override
        public void run() {
            try {
                System.out.println(Thread.currentThread().getName()+"  启动了，等待main线程调度.......");
                startSignal.await();
                doWork();
                System.out.println(Thread.currentThread().getName()+"  完活 ..... ");
                dongSignal.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }


        void doWork() throws InterruptedException {

            System.out.println(Thread.currentThread().getName()+"  开始工作 ..... ");
            Thread.sleep(5000);

        }
    }



    public static void main(String[] args) throws InterruptedException {


        CountDownLatch startSignal=new CountDownLatch(1);//
        CountDownLatch doneSignal=new CountDownLatch(5);

        for(int i=0;i<5;i++){

            new Thread(new Worker(startSignal,doneSignal)).start();
        }
        Thread.sleep(4000);
        System.out.println(Thread.currentThread().getName()+"线程准备就绪，所有线程可以开始工作了..... ");
        startSignal.countDown();
        doneSignal.await();

        System.out.println(Thread.currentThread().getName()+"线程监控任务结束 ");






    }
}


```

执行完成之后，输出结果如下：

```
Thread-0  启动了，等待main线程调度.......
Thread-2  启动了，等待main线程调度.......
Thread-1  启动了，等待main线程调度.......
Thread-3  启动了，等待main线程调度.......
Thread-4  启动了，等待main线程调度.......
main线程准备就绪，所有线程可以开始工作了.....
Thread-0  开始工作 .....
Thread-2  开始工作 .....
Thread-4  开始工作 .....
Thread-3  开始工作 .....
Thread-1  开始工作 .....
Thread-2  完活 .....
Thread-3  完活 .....
Thread-4  完活 .....
Thread-1  完活 .....
Thread-0  完活 .....
main线程监控任务结束

```

上面的例子就是一个非常典型的例子，反应到实际生活的场景比如，张三生日party，准备在一个大酒店进行，客房里面有4个服务员等待服务上菜，前提是张三所有的朋友必须到齐才能开始宴会，然后张三就是协调者，在所有朋友到齐之后，张三发话开始上菜，这时候4个服务员就可以去同时进行上菜。这个例子里面就和上面我们代码执行的例子非常类似。此外还有在web服务器中，必须等缓存初始化之后，我们的程序才对外提供服务，那么这个场景也可以使用CountDownLatch来完成。


这里大家需要避免一个误区，大多数时候我们都是多个线程调用	countDown，只有一个线程调用await， 但实际情况是await方法也是可以有多个线程调用的，而这正是共享锁的体现。


关于CountDownLatch使用的几个步骤：

（1）构造函数指定需要等待的线程数量

（2）对于执行countDown方法的线程为了安全起见这个调用必须写在finally块里面，防止线程发生异常退出，导致程序永远不会终止。



（3）对于异常终止判断，我们可以通过一个布尔变量或者CountDownLatch的getCount方法来判断是不是有的任务异常退出，从而决定需要做什么


```

@Override protected void onKernalStart0()
                    throws IgniteCheckedException {
    try {
        queueHdrView = cctx.cache();
        initFlag = true;
    }
    finally {
        initLatch.countDown();
    }
}
```

（4）对于执行await方法的线程，我们需要判断是否有效，如果无效则要抛出终端异常。


```

public static void await(CountDownLatch latch)
              throws IgniteInterruptedCheckedException {
    try {
        if (latch.getCount() > 0)
            latch.await();
    }
    catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new IgniteInterruptedCheckedException(e);
    }
}
```

最后需要注意的是CountDownLatch仅仅只能被用一次，不能被重置，如果需要循环重置则需要使用Java并发工具包的另外一个类CyclicBarrier。这个会在下一篇文章中介绍。








