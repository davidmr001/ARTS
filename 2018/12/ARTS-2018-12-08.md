
 [Algorithm](#algorithm)

 [Review](#review)

 [Technique 多个线程如何轮流打印ABC特定的次数？](#technique)

 [Share 什么是水塘抽样算法（Reservoir Sampling）](#share)


# Algorithm


# Review


# Technique

之前的一篇文章，我给出了关于多线程应用的几个例子：

都是基于Java里面Lock锁实现的，分别是：

（1）两个线程轮流打印奇数和偶数

（2）多个线程模拟买票

（3）模拟生产者消费者


今天再抛砖引玉，思考一下如何在多个线程中，轮流打印特定顺序的信息多少次。

这类问题其实并不难，只要掌握了Java里面线程协作和锁的知识，就可以轻而易举的搞定：

根据这些，我们来假设一个场景，使用三个线程轮流打印ABC字符串3次。

解决思路：

首先需要声明3个线程，我们可以分别叫A线程，B线程，C线程：

在这里面：

A线程仅仅负责打印A。

B线程仅仅负责打印B。

C线程仅仅负责打印C。

但是呢，他们必须是有顺序，也就是说A打印完之后，才能打印B，B打印完后才行打印C，这就涉及线程协作和通信的知识了，A线程打印完毕之后，要通知B线程打印，B线程打印完之后要通知C线程打印，如果有多轮的话，C线程打印完毕之后，还要通知A线程。以及控制多轮次数的终结，不能让程序陷入死循环之中。

在仔细理一下：

（1）首先三个线程启动后，一定是A线程先打印。如果是其他线程先启动，则必须等待，线程间的通信，我们用共享变量来解决。（本质是通过共享内存）

（2）A运行的时候，B和C都在等待

（3）B运行的时候，A和C都在等待

（4）C运行的时候，A和B都在等待

（5）A运行结束通知B运行

（6）B运行结束通知C运行

（7）C运行结束通知A运行

（8）同时，如果要控制几轮打印，则需要在运行时控制循环次数，因为C线程是每一轮的结束标志，循环次数的加和要在C线程里面做。


ok，主要的逻辑基本理清了，我们看下如何用代码实现，先看核心的类：

定义了共享的监视器对象，计数器，共享变量，然后定义了三个方法分别负责打印A,B,C，功能的实现主要用了synchronized + 监视器的wait，notifyAll方法。


```
     static class PrintABC{

         final  Object monitor=new Object();
         volatile  int count=1;//轮次计数，从1开始，为了保证可见性，这里需要用volatile修饰
         String id="A";//贡献的
         int printCount ;

         public PrintABC(int printCount) {
             this.printCount = printCount;
         }

         public void printA() throws InterruptedException {
             while (count < printCount) {
                 synchronized (monitor) {
                     while (!id.equals("A")) {
                         monitor.wait();
                     }
                     System.out.println(Thread.currentThread().getName() + "打印： " + id);
                     id = "B";
                     monitor.notifyAll();
                 }

             }
         }

             public void printB() throws InterruptedException {
                 while (count < printCount) {
                     synchronized (monitor) {
                         while (!id.equals("B")) {
                             monitor.wait();
                         }
                         System.out.println(Thread.currentThread().getName() + "打印： " + id);
                         id = "C";
                         monitor.notifyAll();
                     }

                 }
             }

         public void printC() throws InterruptedException {
             while (count < printCount +1) {//最后一次终结线程，需要多加一次
                 synchronized (monitor) {
                     while (!id.equals("C")) {
                         monitor.wait();
                     }
                     System.out.println(Thread.currentThread().getName() + "打印： " + id+"\n");
                     id = "A";
                     count=count+1;
                     monitor.notifyAll();
                 }

             }
         }

    }
```


然后，我们看下，main方法如何编写：


```
    public static void main(String[] args) {

        PrintABC printABC=new PrintABC(3);

        Thread t1=new Thread(()->{
            try {
                printABC.printA();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        });
        t1.setName("A线程");


        Thread t2=new Thread(()->{
                try {
                    printABC.printB();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
        });
        t2.setName("B线程");

        Thread t3=new Thread(()->{
                try {
                    printABC.printC();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
        });
        t3.setName("C线程");

        t2.start();
        t3.start();
        t1.start();



    }
```


这里我们设置了3，也就是仅仅打印3轮，就终止程序。结果如下：


```java
A线程打印： A
B线程打印： B
C线程打印： C

A线程打印： A
B线程打印： B
C线程打印： C

A线程打印： A
B线程打印： B
C线程打印： C
```


至此，这个问题就搞定了，我们思考下，因为这里面采用的是Java的内置锁synchronized来实现的，synchronized关键词虽然使用起来非常简单，但是由于它出现的早，本身也有一些缺点，细心的朋友可能已经发现，上面的通信代码处用的是：

```
monitor.notifyAll();
```
注意这个地方，明明我们只需要唤醒一个线程，为什么需要notifyAll()而不是用notify()，这么做的主要目的是因为synchronized的监视器唤醒的线程是随机的，没办法精确到某个线程，所以它必须唤醒所有的线程，然后重新参与锁的竞争，这样就导致部分线程调度没必要的被交换了一次。

这个地方恰内置锁synchronized的一个弊端，这也是为什么在jdk5之后引入的Lock这样高级锁接口，其相比synchronized在加锁的时候，主要优点是：

（1）提供了公平和非公平调度

（2）可中断

（3）可提供非阻塞

（4）可超时

（5）提供了Condition更细粒度的，锁唤醒条件队列



本文中的例子，完全可以用Lock接口+Condition来达到更细粒度的锁控制，也就是A线程执行完之后，仅仅只唤醒B线程，没有必要把C线程也唤醒，感兴趣的朋友可以思考下怎么实现。










# Share


问题描述：

给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出这组数据的k个概率相等的均匀抽样。

要求：

（1）仅扫描数据一次。

（2）空间复杂度为O(K)。空间复杂度与整个数据量无关，只与抽样大小有关。

（3）扫描到数据的前n 个数据时（n>k）,保存当前已扫描数据的k个均匀抽样。


根据要求，首先体积很大内存一次装不下，不能直接不能直接取N内的k个随机数，因为N的长度是未知的。此外也不能采用不能先遍历一遍，然后分块存储数据，再随机选取。最后要求是数据选取绝对随机的保证。


解法：采用水塘抽样算法（Reservoir Sampling）

代码非常简单，如下

```java
    /***
     * 
     * @param input 模拟的原始数组
     * @param k 采样的的个数
     * @return  返回采样的数据
     */
    public static int[]  sample(int []input,int k){
        Random random=new Random();
        int []ret=new int[k];

        for (int i = 0; i <input.length ; i++) {
            if(i<k){
                ret[i]=input[i]; //先取，前k个数字放在数组里面
            }else{//如果i>k，在1-i之间，取一个随机数字，如果这个随机数字小于k，就替换数组，否则就继续遍历，知道结束
               int rand=random.nextInt(i);//
               if(rand<k){
                   ret[rand]=input[i];
               }
            }
        }
     return  ret;
    }
```


算法思路如下：

（1）如果接受的数据量小于k，则依次放入采样数组中

（2）当接收到第i个数据，i大于等于k时，在[0,i]的范围内取一个随机数d
如果d落在了[0,k-1]的范围内，则取接收到的第i个数据替换采样数组中下标等于d位置上的值。

（3）重复步骤2。


该算法的精妙之处在于，当处理到数据源里面第n个数据时，采样数组里面的数据，总是均匀的抽样。


推导证明：

（1）第一步初始化。出现在水库中的前k个元素，直接保存在数组A中。前k个数被选中的概率都是一致的，都是1。
（2）第二步。在处理第k+1个元素时分两种情况：

情况1：第k+1个元素未被选中，数组中没有元素被替换；此时，数组中每个元素的出现概率肯定是一样的，这很显然。但具体是多少呢？就是第k+1个元素未被选中的概率：1-P(第k+1个元素被选中)=1-k/(k+1)=1/(k+1)。（由于第k+1个元素被选中的概率是k/(k+1)（根据公式k/i））

情况2：第k+1个元素被选中，数组中某个元素被第k+1个元素替换掉。第k+1个元素被选中的概率是k/(k+1)（根据公式k/i），所以这个新元素在水库中出现的概率就一定是k/(k+1)（不管它替换掉哪个元素）。下面来看水库中原有元素最终还能留在水库中的概率，水库中原有数据被替换的几率都相等为1/k。水库中任意一个元素被替换掉的概率是：(k/k+1)*(1/k)=1/(k+1)，意即首先要第k+1个元素被选中，然后该元素在k个元素中被选中。那它未被替换的概率就是1-1/(k+1)=k/(k+1)。可以看出来，旧元素和新元素出现的概率是相等的。

（3）第k+1之后面每个元素都重复第二步，即第i （i>k+1）个元素以k/i的概率决定是否将它放入蓄水池，最终所有元素出现在水库中的概率相等。



总结：

其实，这种算法的能保证概率相等的前提就是： 当数据总量加1的时候，都会在当前总量的范围内，进行生成随机数，这样就能保证范围内的所有的数字出现概率都是相等的，然后根据概率均等随机数字来判断，是否落在了我们采样数组的边界中，如果落到了就替换原来数组中相同的位置的值，如果没有落到，就继续遍历选取，直到所有的数据处理完毕。









