
 [Algorithm](#algorithm)

 [Review](#review)

 [Technique](#technique)

 [Share 操作系统之CPU知识扫盲](#share)


# Algorithm


# Review


# Technique


# Share

![image](https://c8.alamy.com/comp/BNNGNJ/two-intel-pci-cpu-controllers-on-a-dell-computer-system-board-BNNGNJ.jpg)
（上图是一个拥有两个物理cpu的主板电路，图片来源于网络）

### 前言
CPU的英文全称是（Central Processing Unit），中文意思翻译中央处理器，是计算机的主要设备之一，功能主要是解释计算机指令以及处理计算机软件中的数据。计算机的可编程性主要是指对中央处理器的编程。


### 关于冯·诺依曼结构

![image](https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Von_Neumann_architecture.svg/1920px-Von_Neumann_architecture.svg.png)

冯·诺依曼结构（Von Neumann architecture）是一种将程序指令存储器和数据存储器合并在一起的计算机设计概念结构。冯·诺依曼结构隐约指导了将存储设备与中央处理器分开ß的概念，因此依本结构设计出的计算机又称存储程序计算机，这也是目前大多数计算机设计的主要参考原则。

最早的计算机器仅内含固定用途的程序。现代的某些计算机依然维持这样的设计方式，通常是为了简化或教育目的。例如一个计算器仅有固定的数学计算程序，它不能拿来当作文字处理软件，更不能拿来玩游戏。若想要改变此机器的程序，你必须更改线路、更改结构甚至重新设计此机器。当然最早的计算机并没有设计的那么可编程。当时所谓的“重写程序”很可能指的是纸笔设计程序步骤，接着制订工程细节，再施工将机器的电路配线或结构改变。

而存储程序型计算机的概念改变了这一切。借由创造一组指令集结构，并将所谓的运算转化成一串程序指令的运行细节，可让程序运行时自我修改程序的运算内容，让此机器更有弹性。借着将指令当成一种特别类型的静态数据，一台存储程序型计算机可轻易改变其程序，并在程控下改变其运算内容。 冯·诺伊曼结构与存储程序型计算机是互相通用的名词。而哈佛结构则是一种将程序数据与普通数据分开存储的设计概念，但是它并未完全突破冯.诺伊曼架构。



### CPU执行原理

CPU的主要运作原理，不论其外观，都是执行储存于被称为程序里的一系列指令。在此讨论的是遵循普遍的冯·诺伊曼结构（von Neumann architecture）设计的装置。程序以一系列数字储存在计算机存储器中。差不多所有的冯·诺伊曼CPU的运作原理可分为四个阶段：提取、解码、执行和写回。

（1）提取

从程序内存中检索指令（为数值或一系列数值）。由程序计数器指定程序存储器的位置，程序计数器保存供识别目前程序位置的数值。换言之，程序计数器记录了CPU在目前程序里的踪迹。提取指令之后，PC根据指令式长度增加存储器单元[iwordlength]。指令的提取常常必须从相对较慢的存储器查找，导致CPU等候指令的送入。这个问题主要被论及在现代处理器的缓存和管线化架构。


（2）解码

CPU根据从存储器提取到的指令来决定其执行行为。在解码阶段，指令被拆解为有意义的片断。根据CPU的指令集架构（ISA）定义将数值解译为指令[isa]。一部分的指令数值为运算码，其指示要进行哪些运算。其它的数值通常供给指令必要的信息

（3）执行

在提取和解码阶段之后，接着进入执行阶段。该阶段中，连接到各种能够进行所需运算的CPU部件。例如，要求一个加法运算，算术逻辑单元将会连接到一组输入和一组输出。输入提供了要相加的数值，而且在输出将含有总和结果。ALU内含电路系统，以于输出端完成简单的普通运算和逻辑运算（比如加法和比特运算）。如果加法运算产生一个对该CPU处理而言过大的结果，在标志寄存器里，溢出标志可能会被设置

（4）写回

最终阶段，写回，以一定格式将执行阶段的结果简单的写回。运算结果经常被写进CPU内部的寄存器，以供随后指令快速访问。在其它案例中，运算结果可能写进速度较慢，如容量较大且较便宜的主存



注意，这上面的4个阶段与我们编写程序是非常相关的，但编程语言里面可能会简化，并把2和3阶段合并，分为：加载，处理，写回。在多线程编程里面，了解这几个概念至关重要，由此可以延伸，数据从哪里加载，在哪里执行，最后结果又写回了哪里。指令数据一般从内存里面加载，但是内存的访问时间，相比cpu慢了n多倍，所以为了加速处理，cpu一般把指令给加载到离cpu更近的寄存器里面，或者是L1,L2,L3的cache来提速，最终计算出来的结果，还要写回内存。正是因为cpu执行指令复杂，所以这里面其实牵扯到很多问题，比如多个线程如何协作处理任务，以及如何保证程序数据的原子性，有序性，可见性。而这正是Java的内存模型出现的意义。在其他不同的编程语言里面其实都有在操作系统之上抽象的内存模型来应对不同的cpu架构的的差异，这一点需要注意。


### 多个单核CPU vs  单个多核CPU

多个单核CPU：

成本更高，因为每个CPU都需要一定的线路电路支持，这样对主板上布局布线极为不便。并且当运行多线程任务时，多线程间通信协同合作也是一个问题。依赖总线的传输，速度较慢，且每一个线程因为运行在不同的CPU上。导致不同线程间各开一个Cache，会造成资源的浪费，同时如果线程间协作就会有冗余数据的产生，更加大了内存的开销。

单个多核CPU：

可以很好地规避基本上多个单核CPU提到的所有缺点。他不需要考虑硬件上的开销以及复杂性问题，同时也可以很好地解决多线程间协同工作的问题，减少内存的开销，因为多线程程序在多核CPU中运行是共用一块内存区的，数据的传输速度比总线来的要快同时不会有冗余数据的产生。单个多核CPU的问题也是显而易见的，假设俩大程序，每一个程序都好多线程还几乎用满cache，它们分时使用CPU，那在程序间切换的时候，光指令和数据的替换就是个问题。



单个多核cpu已经成为个人计算机的主流配置，多个多核的cpu在一些大型的服务器里面也很常见。



### 超线程

“超线程”（Hyperthreading Technology）技术就是通过采用特殊的硬件指令，可以把两个逻辑内核模拟成两个物理超线程芯片，在单处理器中实现线程级的并行计算，同时在相应的软硬
超线程技术效果图
超线程技术效果图
件的支持下大幅度的提高运行效能，从而使单处理器上模拟双处理器的效能。其实，从实质上说，超线程是一种可以将CPU内部暂时闲置处理资源充分“调动”起来的技术。

每个单位时间内，CPU只能处理一个线程，以这样的单位进行，如果想要在单位时间内处理超过一个的线程，是不可能的，除非是有两个核心处理单元，英特尔的HT技术便是以单个核心处理单元，去整合两个逻辑处理单元，也就是一个实体核心，两个逻辑核心，在单位时间内处理两个线程，模拟双核心运作。

简单的说，超线程就是在单个core中，模拟出两个逻辑处理单元，以此能够提高程序执行的并发能力，提高系统cpu资源的利用率。


至此，关于CPU的个数，核数，逻辑CPU的个数计算关系如下：

 （1）总核数 = 物理CPU个数 X 每颗物理CPU的核数

 （2）总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数

一些概念解释如下：

```
           ① 物理CPU
              实际Server中插槽上的CPU个数
              物理cpu数量，可以数不重复的 physical id 有几个
           ② 逻辑CPU
              Linux用户对 /proc/cpuinfo 这个文件肯定不陌生. 它是用来存储cpu硬件信息的
              信息内容分别列出了processor 0 – n 的规格。这里需要注意，如果你认为n就是真实的cpu数的话, 就大错特错了
              一般情况，我们认为一颗cpu可以有多核，加上intel的超线程技术(HT), 可以在逻辑上再分一倍数量的cpu core出来
              逻辑CPU数量=物理cpu数量 x cpu cores 这个规格值 x 2(如果支持并开启ht)
              备注一下：Linux下top查看的CPU也是逻辑CPU个数
           ③ CPU核数
              一块CPU上面能处理数据的芯片组的数量、比如现在的i5 760,是双核心四线程的CPU、而 i5 2250 是四核心四线程的CPU
              一般来说，物理CPU个数×每颗核数就应该等于逻辑CPU的个数，如果不相等的话，则表示服务器的CPU支持超线程技术
```


在linux上查看这些信息命令如下：

```shell
# 查看物理CPU个数
cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l

# 查看每个物理CPU中core的个数(即核数)
cat /proc/cpuinfo| grep "cpu cores"| uniq

# 查看逻辑CPU的个数
cat /proc/cpuinfo| grep "processor"| wc -l
```

举例，在一个Mac Pro的机器上，可以通过关于本机，系统报告选项中，看到当前系统的基本配置情况，如下：

```
  型号名称：	MacBook Pro
  型号标识符：	MacBookPro11,4
  处理器名称：	Intel Core i7
  处理器速度：	2.2 GHz
  处理器数目：	1
  核总数：	4
  L2 缓存（每个核）：	256 KB
  L3 缓存：	6 MB
  内存：	16 GB
  Boot ROM 版本：	187.0.0.0.0
  SMC 版本（系统）：	2.29f24
  序列号（系统）：	C02SK27CG8WN
  硬件 UUID：	652D3965-1BF1-5614-AA0D-63DC5B6DD347

```

比如上面的信息中，显示了当前的系统物理上只拥有一个cpu，但是这个cpu有4个核。然后，我们查询其逻辑cpu的个数，会发现显示是8个：
（在Mac上打开活动监视器，然后双击最下面的中间的cpu负载的地方，就可以看到）

[img]

这就是因为每个核又有2个超线程，所以8个逻辑cpu个数=1物理cpu个数 * 4核 * 2个超线程，最终也就是说如果我要编写一个多线程计算密集型的程序任务，起的线程数可以以逻辑cpu的个数作为参照。当然如果是io密集型的任务，可以开的更多一点。


### CPU性能参数

计算机的性能在很大程度上由CPU的性能决定，而CPU的性能主要体现在其运行程序的速度上。影响运行速度的性能指标包括CPU的工作频率、Cache容量、指令系统和逻辑结构等参数。

大多数情况下，我们主要关注的是CPU的主频，也称时钟频率，是指同步电路中时钟的基础频率，它以“每秒时钟周期”（clock cycles per second）来度量，单位是兆赫（MHz）或千兆赫（GHz）用来表示CPU的运算、处理数据的速度。通常，主频越高，CPU处理数据的速度就越快。

在上面的mac的参数里面，我们能够看到在Intel Core i7处理器下，主频是2.2 GHz，当前主频高的处理器也在4 GHz之内，其主要原因主要在于散热，提高主频超过一定范围后
热密度急速提高，很不经济，也造成散热困难。



### 总结

本文主要介绍了计算机操作系统中CPU有关的知识，计算机的核心就在于CPU，了解CPU相关的知识，可以让我们更清楚我们的程序底层执行的过程，从而写出更健壮的代码及调优相关的程序。






